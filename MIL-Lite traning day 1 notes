MappAllocDefault(initFlag, ApplicationIdPtr, SystemIdPtr, DisplayIdPtr, DigIdPtr, ImageBuffIdPtr)

此宏释放使用MappAllocDefault（）宏分配的MIL应用程序默认值。注意，此功能不会影响系统显示屏上显示的内容;如果你想清除显示，你应该在调用MappFreeDefault()之前使用MdispDeselect（）

使用MILConfig工具去修改MIL的默认设置，default system， digitizer， display， and buffer
如果您经常使用相同的相机并且更喜欢使用MappAllocDefault（）来设置和初始化您的系统，您可能需要更新MILConfig文件以反映您的相机

安装后，如果指定了彩色摄像机，则使用MappAllocDefault（）分配的默认图像缓冲区将是三波段彩色图像缓冲区。但是，如果您没有指定彩色相机，但现在更喜欢使用彩色相机，则可能需要更新MILConfig以反映分配彩色相机和彩色图像缓冲区所需的默认值

MIL_ID  MilApplication,
        MilSystem,
        MilDisplay,
        MilDigitizer,
        MilImage;

/*init resourse*/        
MappAllocDefault(M_COMPLETE, &MilApplication, &MilSystem, &MilDisplay, &MilDigitizer, &MilImage);

/*grab continuously image data*/
MdiaGrabContinuous(MilDIagitizer, MilImage);

MosGetch(); // get enter key to stop grab

/*stop continuous grab*/
MdiaHalt(MilDiagitizer);

MosGetch();// get enter key to start single image

/*monoshot grab*/
MdigGrab(MilDigitizer, MilImage);

MosGetch();//get enter key to free default resource

/*free default resource*/
MappFreeDefault(MilApplication,	MilSystem, 	MilDisplay, MilDigitizer, MilImage);


                        Installing MIL
在安装过程中，系统会询问您一些问题，例如：
•要安装程序的驱动器和目录。
•在64位OS（32位或64位或两者）的情况下安装MIL的平台。
•计算机中安装的Matrox硬件类型（例如，Matrox Morphis）。
•是否安装MGA驱动程序。只会询问您是否有带显示部分或Matrox图形卡的Matrox成像板，并且要安装的驱动程序比计算机上已有的驱动程序更新。
•使用MILConfig实用程序（稍后解释）中指定的默认配置时，默认情况下要加载的数字化仪和显示格式。如有必要，可在以后修改

如果您没有在安装时选择给定电路板的驱动程序，并且希望在系统中添加此类型的电路板，则必须卸载MIL并重新安装	
如果您不确定将来是否要添加新电路板，请选择所有电路板;如果您选择稍后添加电路板，这可确保所有驱动程序都存在


configure the display type
帧抓取器抓取数据的图像可以显示在Windows桌面上的窗口中（部分或扩展）。对于后一种情况，请注意某些电路板（如VIO）可能具有辅助显示器的特殊功能;有关详细信息，请参阅特定于板的MdispControl（）参考

non-paged memory size 
需要在此处指定为抓取缓冲区保留的线性非分页内存（DMA）的数量。保留的非分页内存量还会确定操作系统可用的剩余RAM量.
您可以为任何板选择的最小线性非分页内存量为1 MB

测试安装结果
您可以编译并运行我们的示例程序mappstart.exe，在\ Users \ Public \ Documents \ Matrox Imaging \ Mil \ Examples \ mappstart目录中，以测试安装。请注意，MIL提供了所有示例的编译版本

MIL Control Center
通过MIL Control Center，您可以访问所有MIL示例和工具

Matrox intellicam


Creating a new MIL project in C++
•要编译MIL应用程序，除了必需的标准C包含文件外，还必须包含mil.h头文件。编译完应用程序后，必须将其与适用于操作系统，编译器和目标板的库或导入库相链接。 MIL库位于\ Matrox Imaging \ Mil \ LIB目录中。
•强烈建议您熟悉MIL的众多示例;通常情况下，当使用适当的示例作为起点时，看似复杂的应用程序会变得简化

                        MIL Portability
MIL data types : portable and os independent.

MIL_INT 
    指定一个整数值
    补充传统的int和long数据类型
    数据深度在32位操作系统上为32位，在64位操作系统上为64位
MIL_UINT
    指定一个无符号整数的值
    数据深度与MIL_INT相同 
MIL_DOUBLE
    指定一个双精度浮点数据类型
    
包含的数据类型有 signed, unsigned, and fixed-length versions of MIL_INT, MIL_UINT, MUL_DOUBLE 数据类型

fixed-length data types
MIL_INT8, MIL_INT16, MIL_INT32, MIL_INT64
MIL_UINT8, ...


MIL_TEXT_CHAR
    字符串数组
    替换 char 数据类型
MIL_TEXT_PTR
    指向字符串数组的指针
    替换 char*
MIL_CONST_TEXT_PTR
    指向字符串常量数组的指针
    代替 const char*
MIL_TEXT_CHAR, MIL_TEXT_PTR, and MIL_CONST_TEXT_PTR
    在应用程序以ASCII获unicode编译都能使用
    提供两个编译器选项之间的可移植性
    
MIL_ID 
    只有可用于声明MIL标识符的选项
    用于标识资源（缓冲区，系统和上下文）
example:
MIL_ID  Milapplication,
        MilSystem,
        MilDisplay,
        MilImage;
MappAllocDefault(M_DEFAULT, &MilApplication, &MilSystem,
                    &MilDisplay, &M_NULL, &MilImage);
                    
                    
                    
                    MIL Porability  
ASCII/Unicode

UTF-16
    16位Unicode转换格式
    可变宽度字符编码
    整个Unicode字符库可编码为16位单词序列
    windows默认的编码格式
    在编译为Unicode客户机时MIL采用的编码格式
UTF-8
    8位Unicode转换格式
    可变宽度的字符编码
    与ASCII兼容的字节码和字符分配的初始编码
    每个字符编码为1～4个字节
        1字节用于表示128个US-ASCII字符
        其他字节数用于表示其他字符集
    如果应用在使用Unicode编码的客户机上编译，MIL将使用该编码格式
    Linux默认的编码格式
    windows不完全支持的编码格式
UTF & Windows behavier
    许多windows程序在文件开始时添加字节序列EF BB BF，以表明文件是使用UTF-8编码的
    当UTF-8被解释为UTF-16时，常常会导致错误
MIL支持Unicode编码
在编译应用是可以选择ASCII或者Unicode编码
MIL_TEXT
    macro用适当的编码（ASCII或Unicode）转换所提供的字符串
    MIL_TEXT不能与char*和run-time字符串一起使用
    只适用与静态变量或纯文本
语法：
    MIL_TEXT("Text to be converted");
例：
    MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT("M_NTSC"), M_AUXILIARY, &MilDisplay1);

    MdispAlloc(MilSystem, M_DEFAULT, MIL_TEXT(""\u3088\u3046\u3053/u305d""), ...);

portability function 可移植函数
c/c++           portability Mil version             description

abs()           MIL_INT MosAbs(MIL_INT n)           计算绝对值
getch()         MIL_INT MosGetch()                  从控制台输入接收一个字符
getchar()       MIL_INT MosGetchar()                从标准输入流读取一个字符
kbhit()         MIL_INT MosKbhit()                  检查控制台是否有键盘输入
main()          MIL_INT MosMain()                   主程序入口函数
printf()        MIL_INT MosPrintf(MIL_TEXT_PTR format, ...)     格式化字符串输出到控制台
sleep()         MIL_INT MosSleep(MIL_INT waitTime)   线程进入睡眠状态
sprintf()       MIL_INT MosSprintf(MIL_TEXT_PTR buffer,         格式化字符串输入到buffer
                    MIL_INT size, MIL_TEXT_PTR format, ...)
strcat()        MIL_INT MosStrcat(MIL_TEXT_PTR strDestination,  合并字符串
                    MIL_INT size, MIL_TEXT_PTR strSource)
strcmp()        MIL_INT MosStrcmp(MIL_TEXT_PTR string1,         比较字符串
                    MIL_TEXT_PTR string2)
strcpy()        MIL_INT MosStrcpy(MIL_TEXT_PTR strDestination,  复制字符串到另一个字符串
                    MIL_INT size, MIL_TEXT_PTR strSource)
strlen()        MIL_INT MosStrlen(MIL_TEXT_PTR str)             获取字符串的长度
strlwr()        MIL_INT MosStrlwr(MIL_TEXT_PTR str)             转换字符串为小写字符
strupr()        MIL_INT MosStrupr(MIL_TEXT_PTR str)             转换字符串为大写字符


Data Type       32-bits OS                  64-bits OS

int             32-bit                      32-bit
long            32-bit                      64-bit(linux), 32-bit(windows)
double          64-bit                      64-bit
MIL_INT         32-bit                      64-bit
MIL_DOUBLE      64-bit                      64-bit
PTR             32-bit                      64-bit

Void Pointers

某些函数的最后一个参数类型是任意类型的指针(void-pointer)
    M...Inquire() and M...GetResult()
数据类型取决于
    1.函数中某一个参数的设置
        MbufInquire(bufId, M_ALLOCATION_OVERSCAN_SIZE, %Value1) // value1 type is MIL_INT
        MbufInquire(bufId, M_ANCESTOR_ID, &value2) // value2 type is MIL_ID
    2.对函数参数集合的添加
        MbufInquire(bufId, M_DRAW_RELATIVE_ORIGIN_X + M_TYPE_DOUBLE, &value4) // value4 type is MIL_INT
        MbufInquire(bufId, MDRAW_RELATIVE_ORIGIN_X, &value3) // value3 type is MIL_DOUBLE


                            Safe Types

1.在MIL API中大多数Inquire函数最后一个参数类型为void*
2.然后，MIL将函数的返回值放在这个指针（void*）指向的地址上，而不管返回值的类型如何
3.错误的数据类型将导致报错
    stack corruption
    array overflow
    unitialized returned data
    segmentation faults
Safe types
1.帮助程序避免错误的指针数据类型转换
2.在32-bit OS移植到64-bit OS时能自动转化对应的数据长度，不管是在ASCII or Unicode
3.只在windows下可以使用

In Debug Mode
    编译期间默认启用安全数据类型
In Release mode
    编译期间默认关闭安全数据类型

如果期望的数据类型和实际函数返回的数据类型不一致，会报警告错误
警告错误不能向error一样被捕获

略过类型检查的原因：
1.数据类型在函数调用是无法预知，这种情况发生在一个函数包装在另一个函数中
    MIL_INT UserWrapperAroundMbufInquire(MIL_ID bufId, MIL_INT INquireTYpe, void* useptr)
    {
        return MbufInquire(bufId, inquireType, usePtr);
    }
